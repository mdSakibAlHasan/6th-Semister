# -*- coding: utf-8 -*-
"""8puzzle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K-mtGf79Ei2b2FSs9cKTa-_VI0X-VZUu
"""

import queue
def is_goal_state(state):
    # return (state == [1, 2, 3, 4, 5, 6, 7, 8, 0]) or (state == [0,1, 2, 3, 4, 5, 6, 7, 8])
    return state == [1, 2, 3, 4, 5, 6, 7, 8, 0]

def get_actions(state):
    blank_index = state.index(0)
    actions = []
    if blank_index % 3 > 0:
        actions.append('left')
    if blank_index % 3 < 2:
        actions.append('right')
    if blank_index >= 3:
        actions.append('up')
    if blank_index < 6:
        actions.append('down')
    return actions

def apply_action(state, action):
    new_state = state.copy()
    blank_index = state.index(0)
    if action == 'left':
        new_state[blank_index], new_state[blank_index - 1] = new_state[blank_index - 1], new_state[blank_index]
    elif action == 'right':
        new_state[blank_index], new_state[blank_index + 1] = new_state[blank_index + 1], new_state[blank_index]
    elif action == 'up':
        new_state[blank_index], new_state[blank_index - 3] = new_state[blank_index - 3], new_state[blank_index]
    elif action == 'down':
        new_state[blank_index], new_state[blank_index + 3] = new_state[blank_index + 3], new_state[blank_index]
    return new_state

def bfs_search(initial_state):
    visited = set()
    my_queue = [(initial_state, [])]
    count = 0

    while my_queue:
        count = count + 1
        print("Intermediate count: ",count)
        current_state, path = my_queue.pop(0)
        visited.add(tuple(current_state))
        # print(visited)

        if is_goal_state(current_state):
            print("Total count: ", count)
            return path

        # if len(my_queue) > 50:
        #   break

        for action in get_actions(current_state):
            # print(action," =action ")
            new_state = apply_action(current_state, action)
            if tuple(new_state) not in visited:
                my_queue.append((new_state, path + [action]))

    print("Total count: ", count)
    return None

def print_solution(initial_state, steps):
    print("Initial State:")
    print_state(initial_state)
    print("\nSteps to Goal State:")
    state = initial_state.copy()
    for step in steps:
        state = apply_action(state, step)
        print_state(state)
        print()

# Function to print the puzzle state in a readable format
def print_state(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])

if __name__ == "__main__":
    initial_state = [5, 2, 8, 4, 1, 7, 0, 3, 6]
    steps_to_goal = bfs_search(initial_state)
    if steps_to_goal:
        print_solution(initial_state, steps_to_goal)
    else:
        print("Goal state not reachable from the initial state.")